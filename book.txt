= Mapnik - The Missing Manual
Hartmut Holzgraefe
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 5
:numbered:
:source-highlighter: coderay

[preface]
== Preface

This is a brain dump of my experience with Mapnik, the map rendering library that powers OpenStreeMap and MapOSMatic, among other things

=== Why yet another ducomentation project?

.Image (c) Randall Munroe https://imgs.xkcd.com/comics/standards.png
image::images/xkcd-standards.png[]

There are different information sources that document certain aspects of Mapnik, but none are really complete, up to date, and easily understandable at the same time ...

Eother existing documentation efforts for Mapnik are:

GitHub Wiki::
The https://github.com/mapnik/mapnik/wiki[Mapnik Wiki on GitHub] is a weird mix of end user and developer documentation that unfortunately is neither complete nor up to date.

Sphinx Docs::
The https://github.com/mapnik/sphinx-docs[Sphinx Docs] project was an attempt to create a Mapnik manual using the https://www.sphinx-doc.org/[Sphinx Documentation Generator], but this project unfortunately never really got anywhere and has seen no update for the last ten years now.

Doxygen::
The mapnik source code contains structured comments from which API reference documentation can be generated using https://www.doxygen.nl/[Doxygen]. http://tux-style.de/osm/mapnik/doxygen/html/index.html[Generated output] can be found online, but is not necessarily fully up to date.

API reference::
There is also http://mapnik.org/mapnik-reference/[versioned API reference] documentation maintained outside of the main Mapnik source, in the separate https://github.com/mapnik/mapnik-reference/[Mapnik Reference] project.

XML reference::
There's a http://gis.19327.n8.nabble.com/attachment/5340415/0/MapnikXMLDescription.pdf[XML reference PDF] created by David Eastcott, but it was written for Mapnik v0.7, while we're at v3.0.23 at the time of this writing, so it's really outdated by now.

[NOTE]
====
This list most likely isn't complete ...
====

=== Why AsciiDoc(tor)?

For someone like me, who comes from a DocBook background (I wrote and translated for the PHP manual, and implemented parts of its translation infrastructure, a long time ago, and also worked with a DocBook generated manual a lot in my MySQL days), AsciiDoc feels more "natural" than MarkDown (which is more single document focussed and not really targeting whole books), or Sphinx to me.

== Introduction

Mapnik is a Free Toolkit for developing mapping applications. It is written in modern C++ and has Python bindings that support fast-paced agile development. It can comfortably be used for both desktop map design and web development.

=== Concept

Mapnik is a library, not a complete application program. So it always to be linked to at least a minimum of application code that controls the library operations. 

In the most simple case the application program just creates a Mapnik Map object of a certain size, loads a XML style sheet, and renderes this style into an output file, e.g. when using the Python Mapnik bindings:

.A minimal Mapnik source and style
====
Python API code:
[source,python]
----
#! /usr/bin/env /usr/bin/python3

import mapnik

map = mapnik.Map(600,300) # create a 600x300 pixel map

mapnik.load_map(map, 'points.xml') # loat style file

map.zoom_all() # make sure all data is visible
map.zoom(-1.1) # zoom out a bit more to avoid clipping

mapnik.render_to_file(map, 'point.png', 'png') # render
----

Style file including inline data:
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Map background-color='lightgreen'>

  <Style name="style">
    <Rule>
      <PointSymbolizer/>
    </Rule>
  </Style>

  <Layer name="layer">
    <StyleName>style</StyleName>
    <Datasource>
      <Parameter name="type">csv</Parameter>
      <Parameter name="inline">
wkt
"POINT(10 10)"
"POINT(20 20)"
"POINT(30 30)"
      </Parameter>
    </Datasource>
  </Layer>

</Map>
----

Result:

image::images/introduction.png[]
====

TODO: do the same with pure python and no separate style file

== Installation

How to install Mapnik ...

=== (((Linux)))Linux




=== Windows

TODO

=== MacOS

TODO


=== 


== Mapnik XML

[NOTE]
====
For now I'll only cover how to create styles using Mapnik XML style files. Documentation of other style file formats, like CartoCSS, or how to create styles purely programatically using C++ or Python code, will have to wait until the XML format documentation is complete, or for someone else to volunteer doing this.
====



=== Map

=== DataSource

A `<Datasource>` can appear in two places: as a named data surce template under `<Map>` or as an actual data source in a `<Layer>`. A data soure template can provide default values for actual layer data sources, e.g. when using a PostGis database as data source a data source template can provide all the connection parameters, so that actual layer data sources only have to provide actual SQL queries.

Example:
[source,xml]
----
<Map>
  <!-- Datasource template ->
  <Datasource name="gis">
    <Parameter name="type">postgis</Parameter>
    <Parameter name="host">gis-db</Parameter>
    <Parameter name="port">5432</Parameter>
    <Parameter name="dbname">gis</Parameter>
    <Parameter name="user">maposmatic</Parameter>
    <Parameter name="password">secret</Parameter>
  </Datasource>
 
  <!-- actual Datasource using the template above for default values ..>
  <Layer name="layer-1">
    <Datasource base="gis">
      <Parameter name="table">
`       SELECT ...
      </Parameter>
    </Datasource>
  </Layer>
</Map>
----

=== FontSet

A ((`<Fontset>`)) contains a list of or more `<Font>` entries that are searched in the listed order when rendering characters. This way a style sheet can specify multiple alternative fonts for different platforms, or different language specific fonts.

Listed fonts that do not exist on the system runnng Mapnik are simply ignored after generating a warning. Also when a certain character is not found in the first font the other fonts are searched in order until one supporting the character is found.

So when e.g. a map is to show both `<TextSymbolizer>` or `<ShieldSymbolizer>` using the ((`fontset_name`)) attribute.

.Fontset definition
====
[source,xml]
----
  <FontSet name="my-fonts">
    <Font face-name="Noto Sans Regular"/>
    <Font face-name="Noto Sans CJK JP Regular"/>
  </FontSet>
----

====


=== Layers

A layer renders data from a data source using one or more styles.

=== Styles

Styles contain a set of rendering rules to render data elements provided by a data source.

=== Rules

A style rule filters data elements provided by a data source, and renders the matching elmements using one or more symbolizers. Rules can also be limited to specific scale factor ranges only, e.g. to implement different zoom level styles.

=== Filters 

Filters specify on what data elements a rule should operate, by evaluating expressions. The expression language supports simple comparisons, logic, math, and regular expression matching.

There are also two special filters that do not evaluate expresions but depend on whether other previous filters in the style found a match:

<ElseFilter> matches if no other filter in a style matched so far, so it can be used as a fallback default.

<AlsoFilter> only matches if at least one previous filter in a style matched.

=== Filter expressions

The filter expression language supports the following constants, operators, and functions. It also allows for referencing data element attributes by putting the attribute name in square brackets `[attribute]` and to change evaluation order by putting expression parts in regular round brackets `(...)`.

TODO: operator precedence
TODO: regular expression match and replace

==== Constants

`true`:: logical true
`false`:: logical false
`pi`:: 3.14159...
`deg_to_rad`:: 0.01745... (pi/180)
`rad_to_deg`:: 57.295... (180/pi)

==== Operators

`+`::
`-`::
`*`::
`/`::
`%`::
`and`, `&&`::
`or`, `||`::
`not`, `!`::
`=`, `eq`, `is`::
`!=`, `<>`, `neq`::
`<`, `lt`::
`\<=`, `le`::
`>`, `gt`::
`>=`, `ge`::
  ...

==== Functions

`sin(x)`:: Sinus
`cos(x)`:: Cosinus
`tan(x)`:: Tangens
`atan(x)`:: Arc Tangens
`exp(x)`:: `e^x^`
`log(x)`:: natural logarithm of `x`
`pow(x,y=`:: `x^y^`
`abs(x)`:: positive absolute value of `x`
`min(x,y)`:: minimum value
`max(x,y)`:: maximum value
`length(str)`:: string length



=== Symbolizers

[NOTE]
====
Right now all the symbolizer examples show a complete XML style file. I'm considering to shorten these to just the actual symbolizer tag and the inline CSV data lines as the rest of these examples is actually redundant, to save some space, with hyperlinks to the actual full example files ...
====

==== BuildingSymbolizer

The ((`<BuildingSymbolizer>`)) renders polygons in a very simple pseudo-3D fashion. The givin fill color us used for the "roof", while its individual red, green and blue values are multiplied by 0.8 to create a more darkened tone for the "walls"

.Table Attributes
[options="header,unbreakable"]
|===
| Attribute      | Value      | Default
| <<example-buildingsymbolizer-fill,((`fill`))>>         | CSS color  | gray
| <<example-buildingsymbolizer-fill-opacity,((`fill-opacity`))>> | foat       | 1.0
| <<example-buildingsymbolizer-height,((`height`))>>       | float      | 0
|===

See also:

* https://github.com/mapnik/mapnik/wiki/BuildingSymbolizer[BuildingSymbolier in Mapnik Wiki]
* http://mapnik.org/mapnik-reference/#3.0.22/building[BuildingSymbolizer in Mapnik Reference]


.BuildingSymbolizer fill
[#example-buildingsymbolizer-fill]
====
[source,xml]
-----
include::examples/BuildingSymbolizer-fill.xml[]
-----
image::examples/BuildingSymbolizer-fill.svg[align="center"]
====

.BuildingSymbolizer fill opacity
[#example-buildingsymbolizer-fill-opacity]
====
[source,xml]
-----
include::examples/BuildingSymbolizer-fill-opacity.xml[]
-----
image::examples/BuildingSymbolizer-fill-opacity.svg[align="center"]
====

.BuildingSymbolizer height
====
[#example-buildingsymbolizer-height]
[source,xml]
-----
include::examples/BuildingSymbolizer-height.xml[]
-----
image::examples/BuildingSymbolizer-height.svg[align="center"]
====

==== GroupSymbolizer

==== LineSymbolizer

The LineSymbolizer specifies how to render linear geometries like lines and polygon outlines. Most of the LineSymbolizer attributes define stroke attributes of the line to draw, like color, width, how line joins and ends should look, and even dash patterns.

There are also some attributes that change the lines geometry itself, like offset, smooth and simplify.


.LineSymbolizer
[options="header,unbreakable"]
|====================
| Attribute           | Value | Default | Description 
| clip                | boolean | false |  
| comp-op             | SVG compositing |  |
| geometry-transform  | SVG transform |  | 
| offset              | float | 0 |  
| rasterize           | full, fast | full |  
| smooth              | 0.0 - 1.0 | 1 |  
| simplify            | float | 0 |  
| simplify-algorithm  | radial-distance, zhao-saalfeld, visvalingam-whyatt, douglas-peucker | radial-distance |  
| stroke              | color | black |  
| stroke-dasharray    | number list | none |  
| stroke-dashoffset   | number list | none | experimental only  
| stroke-gamma        | 0.0 - 1.0 | 1 |  
| stroke-gamma-method | power, linear, none, threshold, multiply | power |  
| stroke-linejoin     | bevel, miter, miter-revert, round | miter |  
| stroke-linecap      | butt, round, square | butt |  
| stroke-miterlimit   | float     | 4 |  
| stroke-opacity      | 0.0 - 1.0 | 1 |  
| stroke-width        | float     | 1 |  
|====================

.LineSymbolizer stroke
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke.xml[]
-----
image::examples/LineSymbolizer-stroke.svg[align="center"]
====

.LineSymbolizer stroke width
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-width.xml[]
-----
image::examples/LineSymbolizer-stroke-width.svg[align="center"]
====

.LineSymbolizer stroke opacity
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-opacity.xml[]
-----
image::examples/LineSymbolizer-stroke-opacity.svg[align="center"]
====

.LineSymbolizer stroke linejoin
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-linejoin.xml[]
-----
image::examples/LineSymbolizer-stroke-linejoin.svg[align="center"]
====

.LineSymbolizer stroke linecap
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-linecap.xml[]
-----
image::examples/LineSymbolizer-stroke-linecap.svg[align="center"]
====

.LineSymbolizer smooth
====
[source,xml]
-----
include::examples/LineSymbolizer-smooth.xml[]
-----
image::examples/LineSymbolizer-smooth.svg[align="center"]
====

.LineSymbolizer dash array
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-dasharray.xml[]
-----
image::examples/LineSymbolizer-stroke-dasharray.svg[align="center"]
====

TODO: gamma, gamma-method, dash-offset, miter-limit, clip, simplify, simplify-algorithm, offset, rasterize, geometry-transform, comp-op

==== LinePatternSymbolizer

==== MarkersSymbolizer

The MarkerSymbolizer is similar to the PointSymbolizer, but has two advantages when used on a line or polygon: it can be drawn multiple times along a line automatically, and it's orientation is rotated according to the current direction of the line instead of always being upright.

TODO: attribute table, examples

==== PolygonSymbolizer

==== PolygonPatternSymbolizer

==== PointSymbolizer

The point symbolizer draws a given image at a point position. When given a line or polygon as input the shape will be put at the middle of the line or center of the polygon. 

If no image file is specified a small square is used as the default point image.

For putting symbols along a line or the edge of a polygon the MarkerSymbolizer is usually a better choice.

.Attributes
[width="100%",options="header,unbreakable"]
|====================
| attribute          | type          | default
| <<example-pointsymbolizer-file,`file`>>             | file path     | none 
| `allow-overlap`    | bool          | false 
| <<example-pointsymbolizer-file,`opacity`>>          | float         | 1.0 
| `ignore-placement` | bool          | false
| `transform`        | SVG transform | identity
| `comp-op`          | Compositing   | none
|====================



.PointSymbolizer file
[#example-pointsymbolizer-file]
====
[source,xml]
-----
include::examples/PointSymbolizer-file.xml[]
-----
image::examples/PointSymbolizer-file.svg[align="center"]
====

.PointSymbolizer opacity
[#example-pointsymbolizer-opacity]
====
[source,xml]
-----
include::examples/PointSymbolizer-opacity.xml[]
-----
image::examples/PointSymbolizer-opacity.svg[align="center"]
====

.PointSymbolizer placement
====
[source,xml]
-----
include::examples/PointSymbolizer-placement.xml[]
-----
image::examples/PointSymbolizer-placement.svg[align="center"]
====

.PointSymbolizer scaling 
====
[source,xml]
-----
include::examples/PointSymbolizer-transform-scale.xml[]
-----
image::examples/PointSymbolizer-transform-scale.svg[align="center"]
====

.PointSymbolizer rotation
====
[source,xml]
-----
include::examples/PointSymbolizer-transform-rotate.xml[]
-----
image::examples/PointSymbolizer-transform-rotate.svg[align="center"]
====

.PointSymbolizer compositing
====
TODO
====

==== RasterSymbolizer

==== ShieldSymbolizer

==== TextSymbolizer

.TextSymbolizer size
====
[source,xml]
-----
include::examples/TextSymbolizer-size.xml[]
-----
image::examples/TextSymbolizer-size.svg[align="center"]
====

.TextSymbolizer text color fill
====
[source,xml]
-----
include::examples/TextSymbolizer-fill.xml[]
-----
image::examples/TextSymbolizer-fill.svg[align="center"]
====

.TextSymbolizer character spacing
====
[source,xml]
-----
include::examples/TextSymbolizer-character-spacing.xml[]
-----
image::examples/TextSymbolizer-character-spacing.svg[align="center"]

====


== Compositing

TODO: extend OSM default style with a big single red dot marker, similar to CartoCSS example page

== Tips and Tricks

=== SVG and PDF document versions

When using default settings, CairoGraphics will create SVG version 1.1 output. This SVG version does not support all available composite operator choices (indexterm2:[comp-op]) though, and so for some comp-op values used in style sheets Cairo will fall back to bitmap rendering and you will end up with a SVG document that only contains one single image tag, and the actual rendered map being one large embedded bitmap image.

To prevent this you need to explicitly set the SVG version to produce to version 1.2:

----
surface.restrict_to_version(cairo.SVGVersion.VERSION_1_2);
----

Same for PDF, here you need to enforce the use of PDF version 1.5:

----
surface.restrict_to_version(cairo.PDFVersion.VERSION_1_5);
----

TODO: Cairo version dependency

=== Make SVG output a bit more editor friendly

SVG created by the CairoGraphics render backend is not really made for being post-processed by a vector graphics program like e.g. InkScape. The generated SVG is completely unstructured and does not really contain any grouping or layers.

To make things even worse any text output is done by emitting single character glyphes. So when trying to post process SVG results by moving some label texts around, you need to take care of selecting every character individually.

The https://github.com/Zverik/mapnik-group-text[Mapnik Group Text] tool by Ilya Zverev. It finds letters and their casing in the generated SVG, tries to find words they form, and then groups the letters per word so that you can easily move words as a whole instead of individual letters.

=== Simplify SVG

Mapnik only supports a subset of SVG when it comes to marker images so far.

When creating images with InkScape, make sure to save your images as "Plain SVG", not "InkScape SVG". Even with that some unsupported constructs may end upSVG files though.

The same is also true for SVG images from other sources.

When it comes to simple unknown attributes Mapnik will throw a warning, but the result will usually still come out OK. In other cases you may end up with weird looking results though. And even when everything looks fine in the end, the emitted warnings can still be annoying, and may hide other, more importantn warnings.

TODO: simple script to resolve the most common cases.

== Glossary

[glossary]

AGG::
    The http://antigrain.com[Anti-Grain Graphics library] used by default for bitmap (PNG, JPEG, ...) output.
    
Cairo:: 
CairoGraphics::
    The http://cairographics.org[Cairo Graphics library] used for vector format output (SVG, PDF, PS) output by default, and also for bitmap output when esplicitly requested.

Compositing::
    Compositing provides different ways to combine data to be drawn with already existing from drawing previous layers.

Harfbuzz::
    https://harfbuzz.github.io/[Harfbuzz] is a Text rendering / shaping library used by Mapnik starting with V3.0

Opacity::
    Defines how opaque or transparent a feature should be. Values range from 0.0 for total transparency to 1.0 for total opacity.
    
Symbolizer::
	A symbolizer describes how features appear on rendered maps.
	
SVG Transformations::
    SVG transformations allow to translate, scale, rotate or skew a shape, either by combining one or more individual operations, or by giving them as a transformation matrix right away.


[index]
== Index

