= Mapnik - The Missing Manual
Hartmut Holzgraefe
:doctype: book
:doctitle: Mapnik - The Missing Manual
:keywords: Maps,Mapnik,OpenStreetMap
:author: Hartmut Holzgraefe
:front-cover-image: images/cover.svg
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 5
:numbered:
:source-highlighter: coderay

[preface]
== Preface

This is a brain dump of my experience with Mapnik, the map rendering library that powers OpenStreeMap and MapOSMatic, among other things

=== Why yet another ducomentation project?

.Image (c) Randall Munroe https://imgs.xkcd.com/comics/standards.png
image::images/xkcd-standards.png[]

There are different information sources that document certain aspects of Mapnik, but none are really complete, up to date, and easily understandable at the same time ...

Other existing documentation efforts for Mapnik are:

GitHub Wiki::
The https://github.com/mapnik/mapnik/wiki[Mapnik Wiki on GitHub] is a weird mix of end user and developer documentation that unfortunately is neither complete nor up to date.

Sphinx Docs::
The https://github.com/mapnik/sphinx-docs[Sphinx Docs] project was an attempt to create a Mapnik manual using the https://www.sphinx-doc.org/[Sphinx Documentation Generator], but this project unfortunately never really got anywhere and has seen no update for the last ten years now.

Doxygen::
The mapnik source code contains structured comments from which API reference documentation can be generated using https://www.doxygen.nl/[Doxygen]. http://tux-style.de/osm/mapnik/doxygen/html/index.html[Generated output] can be found online, but is not necessarily fully up to date.

API reference::
There is also http://mapnik.org/mapnik-reference/[versioned API reference] documentation maintained outside of the main Mapnik source, in the separate https://github.com/mapnik/mapnik-reference/[Mapnik Reference] project.

XML reference::
There's a http://gis.19327.n8.nabble.com/attachment/5340415/0/MapnikXMLDescription.pdf[XML reference PDF] created by David Eastcott, but it was written for Mapnik v0.7, while we're at v3.0.23 at the time of this writing, so it's really outdated by now.

[NOTE]
====
This list most likely isn't complete ...
====

=== Why AsciiDoc(tor)?

For someone like me, who comes from a DocBook background (I wrote and translated for the PHP manual, and implemented parts of its translation infrastructure, a long time ago, and also worked with a DocBook generated manual a lot in my MySQL days), AsciiDoc feels more "natural" than MarkDown (which is more single document focussed and not really targeting whole books), or Sphinx to me.

== Introduction

Mapnik is a Free Toolkit for developing mapping applications. It is written in modern C++ and has Python bindings that support fast-paced agile development. It can comfortably be used for both desktop map design and web development.

=== Concept

Mapnik is a library, not a complete application program. So it always to be linked to at least a minimum of application code that controls the library operations. 

In the most simple case the application program just creates a Mapnik Map object of a certain size, loads a XML style sheet, and renderes this style into an output file, e.g. when using the Python Mapnik bindings:

.A minimal Mapnik source and style
====
Python API code:
[source,python]
----
#! /usr/bin/env /usr/bin/python3

import mapnik

map = mapnik.Map(600,300) # create a 600x300 pixel map

mapnik.load_map(map, 'points.xml') # loat style file

map.zoom_all() # make sure all data is visible
map.zoom(-1.1) # zoom out a bit more to avoid clipping

mapnik.render_to_file(map, 'point.png', 'png') # render
----

Style file including inline data:
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Map background-color='lightgreen'>

  <Style name="style">
    <Rule>
      <PointSymbolizer/>
    </Rule>
  </Style>

  <Layer name="layer">
    <StyleName>style</StyleName>
    <Datasource>
      <Parameter name="type">csv</Parameter>
      <Parameter name="inline">
wkt
"POINT(10 10)"
"POINT(20 20)"
"POINT(30 30)"
      </Parameter>
    </Datasource>
  </Layer>

</Map>
----

Result:

image::images/introduction.png[]
====

TODO: do the same with pure python and no separate style file

== Installation

How to install Mapnik ...

=== (((Linux)))Linux




=== Windows

TODO

=== MacOS

TODO


=== 


== Mapnik XML

[NOTE]
====
For now I'll only cover how to create styles using Mapnik XML style files. Documentation of other style file formats, like CartoCSS, or how to create styles purely programatically using C++ or Python code, will have to wait until the XML format documentation is complete, or for someone else to volunteer doing this.
====



=== Map

.Map Attributes
[options="header,unbreakable",cols="m,d,d,d"]
|===
| base | directory path | none | 
| background-color | color | transparent | 
| background-image | file path | none | 
| background-image-comp-op | SVG composition | none | 
| background-image-opacity | float | 1.0 | 
| srs | proj4 projection | +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs | 
| buffer-size | float | 0.0 | 
| maximum-extent | 4xfloat |  | 
| font-directory | directory path | none | 
| minimum-version | version string | none | 
| path-from-xml | boolean | true | 
|===

=== DataSource

A `<Datasource>` can appear in two places: as a named data surce template under `<Map>` or as an actual data source in a `<Layer>`. A data soure template can provide default values for actual layer data sources, e.g. when using a PostGis database as data source a data source template can provide all the connection parameters, so that actual layer data sources only have to provide actual SQL queries.

Example:
[source,xml]
----
<Map>
  <!-- Datasource template ->
  <Datasource name="gis">
    <Parameter name="type">postgis</Parameter>
    <Parameter name="host">gis-db</Parameter>
    <Parameter name="port">5432</Parameter>
    <Parameter name="dbname">gis</Parameter>
    <Parameter name="user">maposmatic</Parameter>
    <Parameter name="password">secret</Parameter>
  </Datasource>
 
  <!-- actual Datasource using the template above for default values ..>
  <Layer name="layer-1">
    <Datasource base="gis">
      <Parameter name="table">
`       SELECT ...
      </Parameter>
    </Datasource>
  </Layer>
</Map>
----

Mapnik supports several different kinds of data sources, and actually has a plugin interface for these, so that plugins for more data sources can be added "on the fly" without having to rebuild Mapnik itself.

The set of plugins that come with Mapnik itself are caled core plugins. Some former core plugins that are no longer maintained, or never left experimental status, have been moved to a separate non-core plugins repository, and there is also a small number of plugins by outside contributores, which we will refer to as exra data sources below.

==== Core data sources

The core plugins are part of the mapnik source code itself, and usually avaliable in all builds of the mapnik library. (TODO: add link to mappnik github).

===== CSV

The CSV plugin reads simple column separated data from a file when specified using the `file` parameter, or directly from the XML style file when using the `inline` paramter. In the later case all lines following the `inline` parameter tag will be read as CSV input until the closing paramter tag is reached. In case that the inline data contains `<`, `>` or `&` characters, you should enclose it in a `<![CDATA[...]]>` section to prevent the content from being interpreted as XML.

When giving a `file` path, this is taken as relative to the directory the style file is in, unless a `base` parameter is given. In that case a relative `file` path will be interpreted as relative to the directory path given in the `<FileSource>` of that base name.

.CSV data source examples
====
[source,xml]
----
<!-- read from file path/to/file.csv -->
<DataSource>
  <Parameter name="type">csv</Parameter>
  <Parameter name="file">path/to/file.csv</Parameter>
</DataSource>

<!-- read inline data -->
<DataSource>
  <Parameter name="type">csv</Parameter>
  <Parameter name="inline"><![CDATA[
lat,lon,text
52.0,8.5,"Bielefeld"
  ]]></Parameter>
</DataSource>
----
==== 

By default the CSV plugin tries to identify the field delimiter by looking at the first line of the file, checking for `,`, Â´;`, `|` and the `TAB` character. Whatever of these characters seen the most often is considered the separator character, unless you specifcy a different one with the `separator` Parameter, e.g: `<Parameter name="separator">;</Parameter>`.

In cases where the data does not contain a header line, one can be given as content of the `headers` parameter.

The default quoting and escape characters are `"` and `\`, but can be changed with the `quote` and `escape` parameters.

Line endings are auto detected, too, so files with DOS/Windows (`\r\n`), Linux/Unix (`\n`) or MacOS (`\r`) style line endings are read correctly out of the box.

The CSV plugin assumes that the data it reads is UTF-8 encoded, a different encoding can be specified using the `encoding` parameter.

Column data can be referred to by the columns header name, using `[column_name]` placeholders in expressions. The following column names have a special meaning and are used to retrieve actual geometry data for a line:

`lat` or `latitude`:: Point latitude
`lon`, `lng`, `long`, or `longitude`:: Point longitude
`wkt`:: Geometry data in Well Known Text format
`geojson`:: Geometry data in GeoJSON format

So each input file either needs a `lat`/`lon` column pair, or either a `wkt` or `geojson` column to be used as a Mapnik data source.

When parsing the header line fails, or no geometry column(s) can be detected in it, the plugin will print a warning by default, and not return any data. When the `strict` parameter is set to `true`, style processing will be terminated completely by throwing a Mapnik exception.

.CSV data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| encoding | string | utf-8 | Text encoding used in the CSV data
| row_limit | int | none | Read only this many data rows, ignore the rest.
| headers | string | none | Header names if the file contains none on the first line
| strict | boolean | false | Terminate Mapnik on hitting errors?
| quote | char | `"` | Quote character used for string columns in the data
| escpae | char | `\` | TODO: does this even really exist?
| separator | char | auto detected | Field separator, typically `,`, `;`, `|` or `TAB`
| extent | 4xfloat | none | ignore data that is completely outside this extent bounding box
| inline | text | none | CSV data to be read directly from the style file
| file | file path | none | path of CSV file to read 
| base | string | none | name of a <FileSource> to search the input file in
|====================

TODO:: 
* `.index` file support? See also `mapnik-index` utility
* NULL handling?

===== Gdal

.Gdal data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| band | | |
| base | | |
| extent | | |
| file | | |
| max_image_area | | |
| nodata | | |
| nodata_tolerance | | |
| shared | | |
|====================

===== GeoJSON

While the GeoJSON format is also supported by the OGR input plugin, a direct native GeoJSON plugin was added for performance reasons for this more and more common format.

Processig performance can be improved by creating an additional `.index` index file using the <<mapnik-index>> tool.

.GeoJson data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description base
| base | string | none | name of a <FileSource> to find the input file in
| cache_features | boolean | true |
| encoding | string | utf-8 | Encoding used for textual informatin
| file | file path | none | Path of a GeoJSON file to read for input.
| inline | string | none | Inline GeoJSON data as part of the stylefile itself
| num_features_to_query | int | 5 | How many features of a feature set to read up front to determine what property names exist in the data
|====================

.GeoJSON data source example
====
[source,xml]
----
include::examples/DataSource-GeoJSON.xml[]
----
image::examples/DataSource-GeoJSON.svg[align="center"]
====


===== OGR

The OGR input plugin supports a large number of different vector formats via the GDAL/OGR library. For a complete list of supported formats see the https://gdal.org/drivers/vector/index.html[Vector Drivers] list in the GDAL documentation.

The OGR plugin is typically used for GPX -- for which no special input plugin exists -- and OSM data -- for which it replaced the older OSM plugin that has now been moved to the `non-core-plugins` repository and is usally not included in Mapnik binary builds anymore. So we're going into details for these two data formats below only.

.OGR data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| base | directory path | none | name of a <FileSource> to search the input file in
| driver | string| auto detect | actual vector format driver to use 
| encoding | string | utf-8 |
| extent | | |
| file | file path | none | path of input file to read
| inline | string | none | inline vector file data to read directly from style file
| layer | string | none | name of the input layer to actually process
| layer_by_index | int | none | number of the input layer to actually process
| layer_by_sql | | |
| string | string | none | alias for `inline`
|====================

====== OGR GPX

The GPX backend reads GPX XML files and provides the contained data via the following five layers:

routes:: 
    Returns routes from the GPX files `<rte>` tags as lines. Each route is given an extra `route_id` attribute.

tracks::
    Returns tracks from the GPX files `<trk>`/`<trkseg>` tags as multilines. Each track is given an extra `track_id` attribute.

route_points::
    Returns `<rtept>` route points from all routes, with an extra `route_fid` filed referring to the `route_id` of the route that a point belongs to.  

track_points::
    Returns `<trkpt`> track points from all tracks, with extra `track_fid` and `track_seg_id` attributes added.

waypoints::
    Returns a compbination of all route and track points.

Any extra tags that a route, track or point may have, like `<name>` or `<ele>` (for eleveation), can be accessed in filter expressions and symbolizers by name, e.g. as `[name]` or `[ele]`.

.OGR GPX data source example
====
Show a marker for all GPX points with a non-empty `<name>` tag.
[source,xml]
----
<Style name="named_point">
  <Rule>
    <Filter>not ([name] = null or [name] = '')</Filter>
    <PointSymbolizer file="marker.svg"/>
    <TextSymbolizer face-name="DejaVu Sans Book" size="10" placement="point">[name]</TextSymbolizer>
  </Rule>
</Style>

<Layer>
  <StyleName>named_point</StyleName>
  <Datasource>
    <Parameter name="type">ogr</Parameter>
    <Parameter name="driver">gpx</Parameter>
    <Parameter name="file">file.gpx</Parameter>
    <Parameter name="layer">waypoints</Parameter>
  </Datasource>
</Layer>
----
====

For more details see the https://gdal.org/drivers/vector/gpx.html[original GDAL documentation for the GPX backend]

====== OGR OSM 

The OGR plugin can read uncompressed https://wiki.openstreetmap.org/wiki/OSM_XML[OSM XML] data andt the more compact, but not human readable, https://wiki.openstreetmap.org/wiki/PBF_Format[PBF format]. File formats are auto detected when using the `.osm` or `.pbf` file extensions. When using files with other extensions, like e.g. `.xml` for OSM XML, the `driver` parameter needs to be set to `osm` explicitly.

The OSM backend provides data in the following five layers:

`points`:: Nodes that have significant tags attached.
`lines`:: Ways that are recognized as non-area.
`multilinestrings`:: Relations that define a multilinestring (`type=multilinestring` or `type=route`).
`multipolygons`:: Ways that are recognized as areas and relations that form a polygon or multipolygon (e.g. `type=multipolygon` or `type=boundary`)
`other_relations`:: Relations that are not in `multilinestrings` or `multipolygons`

.OGR OSM data source example
====
[source,xml]
----
<Datasource>
  <Parameter name="type">ogr</Parameter>
  <Parameter name="driver">osm</Parameter>
  <Parameter name="file">ways.osm</Parameter>
  <Parameter name="layer">lines</Parameter>
</Datasource>
----
====

While rendering OSM data directly can work out OK for small amounts of data the usually preferred way to present OSM data is to import it into PostGIS using either the <<osm2pgsql>> or <<imposm>> import tool first, and then to use the <<PostGIS Datasource>>. This  requires some extra effort up front, but performs better on larger data sets, and allows for more sophisticated preprocessing of the OSM input data than the few fixed rules statically built into the OGR OSM backend.

For more details see the https://gdal.org/drivers/vector/osm.html[original GDAL documentation for the OSM backend]

===== PgRaster

.PgRaster data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| autodetect_key_field | | |
| band | | |
| clip_rasters | | |
| connect_timeout | | |
| cursor_size | | |
| dbname | | |
| estimate_extent | | |
| extent | | |
| extent_from_subquery | | |
| host | | |
| initial_size | | |
| intersect_max_scale | | |
| intersect_min_scale | | |
| key_field | | |
| password | | |
| persist_connection | | |
| port | | |
| prescale_rasters | | |
| raster_field | | |
| raster_table | | |
| row_limit | | |
| srid | | |
| table | | |
| use_overviews | | |
| user | | |
|====================


===== PostGIS

.PostGIS data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| autodetect_key_field | | |
| connect_timeout | | |
| cursor_size | | |
| dbname | | |
| estimate_extent | | |
| extent | | |
| extent_from_subquery | | |
| geometry_field  | | |
| geometry_table  | | |
| host | | |
| initial_size | | |
| intersect_max_scale | | |
| intersect_min_scale | | |
| key_field | | |
| key_field_as_attribute | | |
| password | | |
| persist_connection | | |
| port | | |
| row_limit | | |
| simplify_dp_preserve | | |
| simplify_geometries | | |
| srid | | |
| table | | |
| twkb_encoding | | |
| user | | |
|====================

===== Raster

.PostGIS data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| base | | |
| extent | | |
| file | | |
| format | | |
| hix | | |
| hiy | | |
| lox | | |
| loy | | |
| multi | | |
| tile_size | | |
| tile_stride | | |
| x_width | | |
| y_width | | |
|====================

===== Shape

The shape input plugin can read the https://en.wikipedia.org/wiki/Shapefile[ESRI shapefile format]. The OGR plugin also supports shapefiles, but the shape plugin has more direct support for this. It is also better maintained and tested.

Shapefiles are often used instead of databases for data that doesn't change that often, or where data available in a database requires some preprocessing. Common examples are boundaries, coastlines, and elevation countour lines.

OpenStreetMap or example provides land polygons, water polygons, coastlines, and antarctic ice sheet polygons and outlines as regularily updated shapefiles on the https://osmdata.openstreetmap.de/[OsmData Download Server]. Due to the way large bodies of land and water are constructed by grouping individual coast line segments into polygon relations in OSM, there's always a risk of such lines not really being closed polygons. The OSM shapefiles are generated by extracting and aggregating the line segments data, and are only published when containing no unclosed polygons.

Another often used source of shapefiles is https://www.naturalearthdata.com/[Natural Earth], which provides public domain geo data for lots of physical and cultural features.

Shapefile processing performance can be increased by creating an index file using the <<shapeindex>> tool that is included in the Mapnik source code, and usually also in binary distribution pacakges. 

.Shape data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| file      | file path | none | shapefile path, `.shp` extension is optional
| base      | string | none | name of a <FileSource> to find the input file in
| encoding  | string | utf-8 | encoding used for text fields in the shapefile
| row_limit |  int | none | maximum number of rows to process
|====================

.Shape data source example
====
[source,xml]
----
include::examples/DataSource-Shape.xml[]
----
image::examples/DataSource-Shape.svg[align="center"]
====

===== SQLite

.SQLite data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| attachdb | | |
| auto_index | | |
| base | | |
| encoding | | |
| extent | | |
| fields | | |
| file | | |
| geometry_field | | |
| geometry_table | | |
| index_table | | |
| initdb | | |
| key_field | | |
| metadata | | |
| row_limit | | |
| row_offset | | |
| table | | |
| table_by_index | | |
| use_spatial_index | | |
| wkb_format | | |
|====================

===== TopoJson

.SQLite data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| base | | |
| encoding | | |
| file | | |
| inline | | |
|====================

==== Non-core

The following plugins used to be part of the mapnik source, but have been moved to an https://github.com/mapnik/non-core-plugins[extra repository] as they are either no longer maintained, or still experimental. These are usually not part of a standard Mapnik installation.

===== Geos

.Geos data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| encoding | | |
| extent | | |
| field_data | | |
| field_name | | |
| gid | | |
| wkt | | |
|====================

See also:

* https://github.com/mapnik/mapnik/wiki/GEOS

===== Kismet

An experimental plugin that reads WLAN location informatin from a Kismet instance.

.Kismet data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| encoding | string | utf-8 | Text encoding
| extent | | |
| host | string | none | Kinsmet server name or IP address
| port | int | 2501 | Port that the Kismet process is listening on
| srs | string | |
|====================

See also:

https://github.com/mapnik/mapnik/wiki/Kismet

===== OCCI

.OCCI data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| encoding | | |
| estimate_extent | | |
| extent | | |
| fields | | |
| geometry_field | | |
| host | | |
| initial_size | | |
| max_size | | |
| password | | |
| row_limit | | |
| row_prefetch | | |
| srid | | |
| table | | |
| use_connection_pool | | |
| user | | |
| use_spatial_index | | |
| use_wkb | | |
|====================


===== OSM

The OSM plugin is no longer maintained as the OGR plugin can read OSM data now, too, and unlike the OSM plugin not only supports the OSM XML format, but also the more compact PBF format. So the old OSM plugin is no longer considered a core plugin now.

.OSM data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| bbox | 4xfloat | none | no longer supported, see also `url`
| encoding | string | utf-8 | Encoding of text fields in the data file
| file | file path | OSM XML data file to read |
| parser | string| libxml | So far libxml is the only possible choice here
| url | string | none | Fetching OSM data from an API url was discontinued in Mapnik v2.3
|====================


===== Python

The experimental python plugin allows for writing data sources using custom Python code. 

.Python data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| encoding | string | utf8 | Text encoding used 
| factory | string | none | A Python callable that impmlements a data source
|====================

See also:

* https://github.com/mapnik/mapnik/wiki/Python-Plugin

===== Rasterlite

.Rasterlite data source parameters
[width="100%",options="header",cols="m,d,d,d"]
|====================
| Parameter | Type | Default | Description 
| base | | |
| file | | |
| table | | |
|====================

==== Other data sources

The following data source plugins are not really part of the Mapnik project, even though some of them have their github repostitory under the mapnik project.

===== Hello World

===== GeoWave

===== Mongo



=== FileSource

A `<FileSource>` can be used as a child of `<Map>` to declare named directory paths that can be referred to by the `base=...` attribute in symbolizers that are able to load image files, like e.g. `<PointSymbolizer>`, `<LinePatternSymbolizer>` etc.

.FileSource attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute Value | Default | Description
| name | string | none |  
|====================

.FileSource example
====
The actual symbol file being used in the example below will be taken from `path/to/symbols/symbol.svg`:

[source,xml]
----
<Map>
  <FileSource name='symbols'>path/to/symbols</FileSource>
  [...]
  <PointSymbolizer base='symbols' file='symbol.svg'/>
  [...]
</Map>  
----
====


=== Font

.Font attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute                 | Value | Default | Description
| face-name | string | none |  
|====================



=== FontSet

A ((`<FontSet>`)) contains a list of or more `<Font>` entries that are searched in the listed order when rendering characters. This way a style sheet can specify multiple alternative fonts for different platforms, or different language specific fonts.

Listed fonts that do not exist on the system runnng Mapnik are simply ignored after generating a warning. Also when a certain character is not found in the first font the other fonts are searched in order until one supporting the character is found.

So when e.g. a map is to show both `<TextSymbolizer>` or `<ShieldSymbolizer>` using the ((`fontset_name`)) attribute.

.FontSet attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute                 | Value | Default | Description
| name | string | "<missing name>" |  
|====================

.FontSet definition
====
[source,xml]
----
  <FontSet name="my-fonts">
    <Font face-name="Noto Sans Regular"/>
    <Font face-name="Noto Sans CJK JP Regular"/>
  </FontSet>
----

====


=== Layer

A layer renders data from a data source using one or more styles.


.Layer attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute                 | Value | Default | Description
| buffer-size               | float | 0 |  
| cache-features            | bool  | false | On layers with multiple styles: read features from data source only once and cache them in memory. Improves perforance, but at the cost of using more memory, so off by default. 
| clear-lable-cache         | bool  | false | Clear the placement cache from previous layers, so that texts, points and markers may overlap with those from previous layers. 
| group-by                  | string | none | On layers with multiple styles these styles are processed one by one in the given order by default. When giving a group-by property, feature elements will be sorted by this property, and styles will be processed in order for each distinct group value. E.g with `group-by=z` and `z` having values from `-1` to `1`, first all features with `z=-1` will be processed using all styles, then all with `z=0`, and finally all with `z=-1`.
| minimum-scale-denominator | float | 0 | Minimum map scale above which this layer should be rendered.
| maximum-extent            | 4x float |  | Maximum exent for which features should be processed. 
| maximum-scale-denominator | float | max. float | Maximum map scale up to which this layer should be rendered.
| name                      | string | none | Name by which the layer can be refeenced, e.g. for error messaes.
| queryable                 | bool | false | unused? 
| srs                       | proj4 srs string | `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs` | Spatial reference system
| status                    | boolean | true | Whether this layer should actually be processed or not. Caution: when set to `false` in XML the complete `<Layer>` will simply be skipped on reading the style file, and no layer object will be created for it. So you won't be able to enable such a layer with `Layer.set_status(true)` using API code later. 
|====================

.Layer 
====
[source,xml]
----
<Layer name="layer_1">
  <StyleName>style_1</StyleName>
  <StyleName>style_2</StyleName>

  <DataSource>
    [...]
  </DataSource>
</Layer>
----
====

=== Style

Styles contain a set of rendering rules to render data elements provided by a data source. Each style can contain one or more rules for rendering specific features.

.Style attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute                 | Value | Default | Description
| comp-op | SVG compositing |  |  
| filter-mode | "all", "first" | "all" |  
| opacity | float | 1 |  
| image-filters-inflate | boolean | false |  
| image-filters | string |  |  
| direct-image-filters | string |  |  
|====================


=== Rule

A style rule filters data elements provided by a data source, and renders the matching elmements using one or more symbolizers. Rules can also be limited to specific scale factor ranges only, e.g. to implement different zoom level styles.

.Rule attributes
[options="header",cols="m,d,d,d"]
|====================
| Attribute                 | Value | Default | Description
| name | string | none |  
|====================


=== Filter

Filters specify on what data elements a rule should operate, by evaluating expressions. The expression language supports simple comparisons, logic, math, and regular expression matching.

There are also two special filters that do not evaluate expresions but depend on whether other previous filters in the style found a match:

<ElseFilter> matches if no other filter in a style matched so far, so it can be used as a fallback default.

<AlsoFilter> only matches if at least one previous filter in a style matched.

The `<Filter>` tag has no tag attributes.

==== Filter expressions

The filter expression language supports the following constants, operators, and functions. It also allows for referencing data element attributes by putting the attribute name in square brackets `[attribute]` and to change evaluation order by putting expression parts in regular round brackets `(...)`.

TODO: operator precedence
TODO: regular expression match and replace

===== Constants

`true`:: logical true
`false`:: logical false
`pi`:: 3.14159...
`deg_to_rad`:: 0.01745... (pi/180)
`rad_to_deg`:: 57.295... (180/pi)

===== Operators

`+`::
`-`::
`*`::
`/`::
`%`::
`and`, `&&`::
`or`, `||`::
`not`, `!`::
`=`, `eq`, `is`::
`!=`, `<>`, `neq`::
`<`, `lt`::
`\<=`, `le`::
`>`, `gt`::
`>=`, `ge`::
  ...

===== Functions

`sin(x)`:: Sinus
`cos(x)`:: Cosinus
`tan(x)`:: Tangens
`atan(x)`:: Arc Tangens
`exp(x)`:: `e^x^`
`log(x)`:: natural logarithm of `x`
`pow(x,y=`:: `x^y^`
`abs(x)`:: positive absolute value of `x`
`min(x,y)`:: minimum value
`max(x,y)`:: maximum value
`length(str)`:: string length



=== Symbolizers

Symbolizers do the actual rendering of map features. There are several different kinds of symbolizers that operate on point, line and polygon data objects to create visual representations on these. Below you will find detailed descriptions of the available symbolizers in alphabetical order.

[NOTE]
====
Right now all the symbolizer examples below show a complete XML style file. I'm considering to shorten these to just the actual symbolizer tag and the inline CSV data lines as the rest of these examples is actually redundant, to save some space, with hyperlinks to the actual full example files ...
====

==== BuildingSymbolizer

The ((`<BuildingSymbolizer>`)) renders polygons in a very simple pseudo-3D fashion. The givin fill color us used for the "roof", while its individual red, green and blue values are multiplied by 0.8 to create a more darkened tone for the "walls"

.BuildingSymbolizer Attributes
[options="header,unbreakable"]
|===
| Attribute      | Value      | Default
| <<example-buildingsymbolizer-fill,((`fill`))>>         | CSS color  | gray
| <<example-buildingsymbolizer-fill-opacity,((`fill-opacity`))>> | foat       | 1.0
| <<example-buildingsymbolizer-height,((`height`))>>       | float      | 0
|===

See also:

* https://github.com/mapnik/mapnik/wiki/BuildingSymbolizer[BuildingSymbolier in Mapnik Wiki]
* http://mapnik.org/mapnik-reference/#3.0.22/building[BuildingSymbolizer in Mapnik Reference]


.BuildingSymbolizer fill
[#example-buildingsymbolizer-fill]
====
[source,xml]
-----
include::examples/BuildingSymbolizer-fill.xml[]
-----
image::examples/BuildingSymbolizer-fill.svg[align="center"]
====

.BuildingSymbolizer fill opacity
[#example-buildingsymbolizer-fill-opacity]
====
[source,xml]
-----
include::examples/BuildingSymbolizer-fill-opacity.xml[]
-----
image::examples/BuildingSymbolizer-fill-opacity.svg[align="center"]
====

.BuildingSymbolizer height
====
[#example-buildingsymbolizer-height]
[source,xml]
-----
include::examples/BuildingSymbolizer-height.xml[]
-----
image::examples/BuildingSymbolizer-height.svg[align="center"]
====

==== GroupSymbolizer

==== LineSymbolizer

The LineSymbolizer specifies how to render linear geometries like lines and polygon outlines. Most of the LineSymbolizer attributes define stroke attributes of the line to draw, like color, width, how line joins and ends should look, and even dash patterns.

There are also some attributes that change the lines geometry itself, like offset, smooth and simplify.


.LineSymbolizer
[options="header,unbreakable",cols="m,d,d,d"]
|====================
| Attribute               | Value | Default | Description 
| ((clip))                | boolean | false |  
| ((comp-op))             | SVG compositing |  |
| ((geometry-transform))  | SVG transform |  | 
| <<example-linesymbolizer-offset,((offset))>>              | float | 0 |  
| ((rasterize))           | full, fast | full |  
| <<example-linesymbolizer-smooth,((smooth))>>              | 0.0 - 1.0 | 1 |  
| ((simplify))            | float | 0 |  
| ((simplify-algorithm))  | radial-distance, zhao-saalfeld, visvalingam-whyatt, douglas-peucker | radial-distance |  
| <<example-linesymbolizer-stroke,((stroke))>>              | color | black |  
| <<example-linesymbolizer-stroke-dasharray,((stroke-dasharray))>>    | number list | none |  
| ((stroke-dashoffset))   | number list | none | experimental only  
| ((stroke-gamma))        | 0.0 - 1.0 | 1 |  
| ((stroke-gamma-method)) | power, linear, none, threshold, multiply | power |  
| <<example-linesymbolizer-stroke-linejoin,((stroke-linejoin))>>     | bevel, miter, miter-revert, round | miter |  
| <<example-linesymbolizer-stroke-linecap,((stroke-linecap))>>      | butt, round, square | butt |  
| ((stroke-miterlimit))   | float     | 4 |  
| <<example-linesymbolizer-stroke-opacity,((stroke-opacity))>>      | 0.0 - 1.0 | 1 |  
| <<example-linesymbolizer-stroke-width,((stroke-width))>>        | float     | 1 |  
|====================


.LineSymbolizer smooth
[#example-linesymbolizer-smooth]
====
[source,xml]
-----
include::examples/LineSymbolizer-smooth.xml[]
-----
image::examples/LineSymbolizer-smooth.svg[align="center"]
====

.LineSymbolizer stroke
[#example-linesymbolizer-stroke]
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke.xml[]
-----
image::examples/LineSymbolizer-stroke.svg[align="center"]
====

.LineSymbolizer dash array
[#example-linesymbolizer-stroke-dasharray]
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-dasharray.xml[]
-----
image::examples/LineSymbolizer-stroke-dasharray.svg[align="center"]
====

.LineSymbolizer stroke linejoin
[#example-linesymbolizer-stroke-linejoin]
====
TODO: prevent image clipping on top edge
[source,xml]
-----
include::examples/LineSymbolizer-stroke-linejoin.xml[]
-----
image::examples/LineSymbolizer-stroke-linejoin.svg[align="center"]
====

.LineSymbolizer stroke linecap
[#example-linesymbolizer-stroke-linecap]
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-linecap.xml[]
-----
image::examples/LineSymbolizer-stroke-linecap.svg[align="center"]
====

.LineSymbolizer stroke opacity
[#example-linesymbolizer-stroke-opacity]
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-opacity.xml[]
-----
image::examples/LineSymbolizer-stroke-opacity.svg[align="center"]
====

.LineSymbolizer stroke width
[#example-linesymbolizer-stroke-width]
====
[source,xml]
-----
include::examples/LineSymbolizer-stroke-width.xml[]
-----
image::examples/LineSymbolizer-stroke-width.svg[align="center"]
====

.LineSymbolizer offset
[#example-linesymbolizer-offset]
====
Note that unlike in other LineSymbolizer examples this is three times the same geometry, but with different `offset`.
[source,xml]
-----
include::examples/LineSymbolizer-offset.xml[]
-----
image::examples/LineSymbolizer-offset.svg[align="center"]
====

See also:

* https://github.com/mapnik/mapnik/wiki/LineSymbolizer[LineSymbolier in Mapnik Wiki]
* http://mapnik.org/mapnik-reference/#3.0.22/line[LineSymbolizer in Mapnik Reference]

TODO: gamma, gamma-method, dash-offset, miter-limit, clip, simplify, simplify-algorithm, rasterize, geometry-transform, comp-op

==== LinePatternSymbolizer

A LinePatternSymbolizer draws a given pattern image along a line, repeating the pattern as often as needed, and transforming it accordingly to follow the turns of the line.

[WARNING]
====
Even when giving the pattern as a SVG file, internally it will be converted to PNG before applying transformations to it to make it fit the line. So when creating SVG or PDF output, the result can still become a bit blurry when zooming in on LinePatternSymbolizer output.
====

.LinePatternSymbolizer Attributes
[options="header,unbreakable",cols="m,d,d,d"]
|===
| Attribute      | Value      | Default | Description
| <<example-linepatternsymbolizer-file,((file))>>         | file path |
| ((base))    | directory path | | 
| opacity |  |  |  
| offset  |  |  |  
| transform |  |  |  
|  |  |  |  
|  |  |  |  
|  |  |  |  
|  |  |  |  
|===

.LinePatternSymbolizer file
[#example-linepatternsymbolizer-file]
====
[source,xml]
-----
include::examples/LinePatternSymbolizer-file.xml[]
-----
image::examples/LinePatternSymbolizer-file.png[align="center"]
// need to use PNG here as ascidoctor-pdf, or actually the 
// prawn-svg renderer used by it, does not support SVG
// <pattern> tags
// see also https://github.com/mogest/prawn-svg/issues/119
====

==== MarkerSymbolizer

The MarkerSymbolizer is similar to the PointSymbolizer, but has two advantages when used on a line or polygon: it can be drawn multiple times along a line automatically, and it's orientation is rotated according to the current direction of the line instead of always being upright.

TODO: attribute table, examples

==== PolygonSymbolizer

.PolygonSymbolizer Attributes
[options="header,unbreakable",cols="m,d,d,d"]
|===
| Attribute      | Value      | Default | Description
| <<example-polygonsymbolizer-fill,((fill))>> | color | grey |  
| <<example-polygonsymbolizer-fill-opacity,((fill-opacity))>> | float | 1.0 |  
| transform | SVG transformation | none |  
| comp-op | SVG composition | none |  
| gamma | float | 1.0 |  
| gamma-method |  power, linear, none, threshold, multiply | power |  
| clip | boolean | false |  
| simplify | float | 0.0 | 
| simplify-algorithm | radial-distance, zhao-saalfeld, visvalingam-whyatt, douglas-peucker | radial-distance | 
| <<example-polygonsymbolizer-smooth,((smooth))>> | float | 0.0 | 
|===

.PolygonSymbolizer fill
[#example-polygonsymbolizer-fill]
====
[source,xml]
-----
include::examples/PolygonSymbolizer-fill.xml[]
-----
image::examples/PolygonSymbolizer-fill.svg[align="center"]
====

.PolygonSymbolizer fill opacity
[#example-polygonsymbolizer-fill-opacity]
====
[source,xml]
-----
include::examples/PolygonSymbolizer-fill-opacity.xml[]
-----
image::examples/PolygonSymbolizer-fill-opacity.svg[align="center"]
====

.PolygonSymbolizer smooth
[#example-polygonsymbolizer-smooth]
====
[source,xml]
-----
include::examples/PolygonSymbolizer-smooth.xml[]
-----
image::examples/PolygonSymbolizer-smooth.svg[align="center"]
====

==== PolygonPatternSymbolizer

.PolygonSymbolizer Attributes
[options="header,unbreakable",cols="m,d,d,d"]
|===
| Attribute      | Value      | Default | Description
| file |  |   |  
| base |  |   |  
| alignment |  |   |  
| gamma |  |   |  
| gamma-method |  |   |  
| opacity |  |   |  
| clip |  |   |  
| simplify |  |   |  
| simplify-algorithm |  |   |  
| smooth |  |   |  
| transform |  |   |  
|  |  |   |  
|  |  |   |  
|  |  |   |  
|===

==== PointSymbolizer

The point symbolizer draws a given image at a point position. When given a line or polygon as input the shape will be put at the middle of the line or center of the polygon. 

If no image file is specified a small square is used as the default point image.

For putting symbols along a line or the edge of a polygon the MarkerSymbolizer is usually a better choice.

.PointSymbolizer Attributes
[width="100%",options="header,unbreakable"]
|====================
| attribute          | type          | default
| <<example-pointsymbolizer-file,`file`>>             | file path     | none 
| `base`             | directory path | none
| `allow-overlap`    | bool          | false 
| <<example-pointsymbolizer-file,`opacity`>>          | float         | 1.0 
| `ignore-placement` | bool          | false
| `transform`        | SVG transform | identity
| `comp-op`          | Compositing   | none
|====================



.PointSymbolizer file
[#example-pointsymbolizer-file]
====
[source,xml]
-----
include::examples/PointSymbolizer-file.xml[]
-----
image::examples/PointSymbolizer-file.svg[align="center"]
====

.PointSymbolizer opacity
[#example-pointsymbolizer-opacity]
====
[source,xml]
-----
include::examples/PointSymbolizer-opacity.xml[]
-----
image::examples/PointSymbolizer-opacity.svg[align="center"]
====

.PointSymbolizer placement
====
[source,xml]
-----
include::examples/PointSymbolizer-placement.xml[]
-----
image::examples/PointSymbolizer-placement.svg[align="center"]
====

.PointSymbolizer scaling 
====
[source,xml]
-----
include::examples/PointSymbolizer-transform-scale.xml[]
-----
image::examples/PointSymbolizer-transform-scale.svg[align="center"]
====

.PointSymbolizer rotation
====
[source,xml]
-----
include::examples/PointSymbolizer-transform-rotate.xml[]
-----
image::examples/PointSymbolizer-transform-rotate.svg[align="center"]
====

.PointSymbolizer compositing
====
TODO
====

==== RasterSymbolizer

==== ShieldSymbolizer

==== TextSymbolizer

.TextSymbolizer size
====
[source,xml]
-----
include::examples/TextSymbolizer-size.xml[]
-----
image::examples/TextSymbolizer-size.svg[align="center"]
====

.TextSymbolizer text color fill
====
[source,xml]
-----
include::examples/TextSymbolizer-fill.xml[]
-----
image::examples/TextSymbolizer-fill.svg[align="center"]
====

.TextSymbolizer character spacing
====
[source,xml]
-----
include::examples/TextSymbolizer-character-spacing.xml[]
-----
image::examples/TextSymbolizer-character-spacing.svg[align="center"]

====


== Compositing

TODO: extend OSM default style with a big single red dot marker, similar to CartoCSS example page

== Tips and Tricks

=== SVG and PDF document versions

When using default settings, CairoGraphics will create SVG version 1.1 output. This SVG version does not support all available composite operator choices (indexterm2:[comp-op]) though, and so for some comp-op values used in style sheets Cairo will fall back to bitmap rendering and you will end up with a SVG document that only contains one single image tag, and the actual rendered map being one large embedded bitmap image.

To prevent this you need to explicitly set the SVG version to produce to version 1.2:

----
surface.restrict_to_version(cairo.SVGVersion.VERSION_1_2);
----

Same for PDF, here you need to enforce the use of PDF version 1.5:

----
surface.restrict_to_version(cairo.PDFVersion.VERSION_1_5);
----

TODO: Cairo version dependency

=== Make SVG output a bit more editor friendly

SVG created by the CairoGraphics render backend is not really made for being post-processed by a vector graphics program like e.g. InkScape. The generated SVG is completely unstructured and does not really contain any grouping or layers.

To make things even worse any text output is done by emitting single character glyphes. So when trying to post process SVG results by moving some label texts around, you need to take care of selecting every character individually.

The https://github.com/Zverik/mapnik-group-text[Mapnik Group Text] tool by Ilya Zverev. It finds letters and their casing in the generated SVG, tries to find words they form, and then groups the letters per word so that you can easily move words as a whole instead of individual letters.

=== Simplify SVG

Mapnik only supports a subset of SVG when it comes to marker images so far.

When creating images with InkScape, make sure to save your images as "Plain SVG", not "InkScape SVG". Even with that some unsupported constructs may end upSVG files though.

The same is also true for SVG images from other sources.

When it comes to simple unknown attributes Mapnik will throw a warning, but the result will usually still come out OK. In other cases you may end up with weird looking results though. And even when everything looks fine in the end, the emitted warnings can still be annoying, and may hide other, more importantn warnings.

TODO: simple script to resolve the most common cases.

== Glossary

[glossary]

AGG::
    The http://antigrain.com[Anti-Grain Graphics library] used by default for bitmap (PNG, JPEG, ...) output.
    
Cairo:: 
CairoGraphics::
    The http://cairographics.org[Cairo Graphics library] used for vector format output (SVG, PDF, PS) output by default, and also for bitmap output when esplicitly requested.

Compositing::
    Compositing provides different ways to combine data to be drawn with already existing from drawing previous layers.

GDAL::
    https://gdal.org/[GDAL] is a library for processing various raster and vector geospatial data formats released by the https://www.osgeo.org/[Open Source Geospatial Foundation] (OSGeo). The vector format support also runs under the name OGR for historical reasons.

GPS::
    Global Positioning System

GPX::
    GPS exchange format - an XML format to represent GPS data.

Harfbuzz::
    https://harfbuzz.github.io/[Harfbuzz] is a Text rendering / shaping library used by Mapnik starting with V3.0

Opacity::
    Defines how opaque or transparent a feature should be. Values range from 0.0 for total transparency to 1.0 for total opacity.

OGR:: 
    The vector format related part of GDAL.
    
OSGeo::
    The https://www.osgeo.org/[Open Source Geospatial Foundation]
    
PBF::
    Protocol Buffer Format - a file format for OSM data based on the https://developers.google.com/protocol-buffers[Google ProtoBuf library]. PBF is a binary format not suitable for human readning, but very compact, with file sizes typically only almost half of bzip2 compressed OSM XML. 
    
Symbolizer::
	A symbolizer describes how features appear on rendered maps.
	
SVG Transformations::
    SVG transformations allow to translate, scale, rotate or skew a shape, either by combining one or more individual operations, or by giving them as a transformation matrix right away.


[index]
== Index

